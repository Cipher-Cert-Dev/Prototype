{"ast":null,"code":"import _createForOfIteratorHelper from \"D:/CC/test/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport { encodeUint, bufPaddedLength, buffLength } from '../common';\nimport { ethersAbi, falseEncoded, trueEncoded } from './constants';\nvar selector = ethersAbi.getSighash('tryAggregate');\nexport function encodeCalls(start, calls) {\n  var res = start;\n  // the first offset is calls.length * 0x20 because the first\n  // item of a dynamic array starts after all offsets\n  var dynamicOffset = calls.length * 0x20;\n  // number of items in the array\n  res += encodeUint(calls.length);\n  var _iterator = _createForOfIteratorHelper(calls),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var call = _step.value;\n      // offset of the current call\n      res += encodeUint(dynamicOffset);\n      // offset for the next call - current offset\n      // + length of the current call\n      // + space taken by the current offset\n      // + the first item in the next tuple - address for the next call\n      // + space taken by the offset for the next call data\n      dynamicOffset += 3 * 0x20 + bufPaddedLength(call[1]);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  var _iterator2 = _createForOfIteratorHelper(calls),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _call = _step2.value;\n      // address + calldata offset\n      dynamicOffset = 0x40;\n      res += '000000000000000000000000' + _call[0].slice(2).toLowerCase();\n      res += encodeUint(dynamicOffset);\n      // call data length\n      res += buffLength(_call[1]).toString(16).padStart(64, '0');\n      // calldata\n      res += _call[1].slice(2).padEnd(bufPaddedLength(_call[1]) * 2, '0');\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return res;\n}\nexport function encodeTryAggregate(b, calls) {\n  // function tryAggregate(bool requireSuccess, tuple(address target, bytes callData)[] calls) public returns (tuple(bool success, bytes returnData)[])\n  var res = selector;\n  // offset of the array is 0x40 because we need to\n  // encode requireSuccess flag and the offset itself\n  var dynamicOffset = 0x40;\n  res += b ? trueEncoded : falseEncoded;\n  res += encodeUint(dynamicOffset);\n  // encode dynamic array of calls\n  return encodeCalls(res, calls);\n}","map":{"version":3,"names":["encodeUint","bufPaddedLength","buffLength","ethersAbi","falseEncoded","trueEncoded","selector","getSighash","encodeCalls","start","calls","res","dynamicOffset","length","_iterator","_createForOfIteratorHelper","_step","s","n","done","call","value","err","e","f","_iterator2","_step2","slice","toLowerCase","toString","padStart","padEnd","encodeTryAggregate","b"],"sources":["D:\\CC\\test\\node_modules\\@usedapp\\core\\src\\abi\\multicall2\\encoder.ts"],"sourcesContent":["import { encodeUint, bufPaddedLength, buffLength } from '../common'\nimport { ethersAbi, falseEncoded, trueEncoded } from './constants'\n\nconst selector = ethersAbi.getSighash('tryAggregate')\n\nexport function encodeCalls(start: string, calls: [string, string][]) {\n  let res = start\n  // the first offset is calls.length * 0x20 because the first\n  // item of a dynamic array starts after all offsets\n  let dynamicOffset = calls.length * 0x20\n  // number of items in the array\n  res += encodeUint(calls.length)\n  for (const call of calls) {\n    // offset of the current call\n    res += encodeUint(dynamicOffset)\n    // offset for the next call - current offset\n    // + length of the current call\n    // + space taken by the current offset\n    // + the first item in the next tuple - address for the next call\n    // + space taken by the offset for the next call data\n    dynamicOffset += 3 * 0x20 + bufPaddedLength(call[1])\n  }\n\n  for (const call of calls) {\n    // address + calldata offset\n    dynamicOffset = 0x40\n    res += '000000000000000000000000' + call[0].slice(2).toLowerCase()\n    res += encodeUint(dynamicOffset)\n\n    // call data length\n    res += buffLength(call[1]).toString(16).padStart(64, '0')\n    // calldata\n    res += call[1].slice(2).padEnd(bufPaddedLength(call[1]) * 2, '0')\n  }\n\n  return res\n}\n\nexport function encodeTryAggregate(b: boolean, calls: [string, string][]) {\n  // function tryAggregate(bool requireSuccess, tuple(address target, bytes callData)[] calls) public returns (tuple(bool success, bytes returnData)[])\n  let res = selector\n\n  // offset of the array is 0x40 because we need to\n  // encode requireSuccess flag and the offset itself\n  const dynamicOffset = 0x40\n  res += b ? trueEncoded : falseEncoded\n  res += encodeUint(dynamicOffset)\n\n  // encode dynamic array of calls\n  return encodeCalls(res, calls)\n}\n"],"mappings":";AAAA,SAASA,UAAU,EAAEC,eAAe,EAAEC,UAAU,QAAQ,WAAW;AACnE,SAASC,SAAS,EAAEC,YAAY,EAAEC,WAAW,QAAQ,aAAa;AAElE,IAAMC,QAAQ,GAAGH,SAAS,CAACI,UAAU,CAAC,cAAc,CAAC;AAErD,OAAM,SAAUC,WAAWA,CAACC,KAAa,EAAEC,KAAyB;EAClE,IAAIC,GAAG,GAAGF,KAAK;EACf;EACA;EACA,IAAIG,aAAa,GAAGF,KAAK,CAACG,MAAM,GAAG,IAAI;EACvC;EACAF,GAAG,IAAIX,UAAU,CAACU,KAAK,CAACG,MAAM,CAAC;EAAA,IAAAC,SAAA,GAAAC,0BAAA,CACZL,KAAK;IAAAM,KAAA;EAAA;IAAxB,KAAAF,SAAA,CAAAG,CAAA,MAAAD,KAAA,GAAAF,SAAA,CAAAI,CAAA,IAAAC,IAAA,GAA0B;MAAA,IAAfC,IAAI,GAAAJ,KAAA,CAAAK,KAAA;MACb;MACAV,GAAG,IAAIX,UAAU,CAACY,aAAa,CAAC;MAChC;MACA;MACA;MACA;MACA;MACAA,aAAa,IAAI,CAAC,GAAG,IAAI,GAAGX,eAAe,CAACmB,IAAI,CAAC,CAAC,CAAC,CAAC;;EACrD,SAAAE,GAAA;IAAAR,SAAA,CAAAS,CAAA,CAAAD,GAAA;EAAA;IAAAR,SAAA,CAAAU,CAAA;EAAA;EAAA,IAAAC,UAAA,GAAAV,0BAAA,CAEkBL,KAAK;IAAAgB,MAAA;EAAA;IAAxB,KAAAD,UAAA,CAAAR,CAAA,MAAAS,MAAA,GAAAD,UAAA,CAAAP,CAAA,IAAAC,IAAA,GAA0B;MAAA,IAAfC,KAAI,GAAAM,MAAA,CAAAL,KAAA;MACb;MACAT,aAAa,GAAG,IAAI;MACpBD,GAAG,IAAI,0BAA0B,GAAGS,KAAI,CAAC,CAAC,CAAC,CAACO,KAAK,CAAC,CAAC,CAAC,CAACC,WAAW,EAAE;MAClEjB,GAAG,IAAIX,UAAU,CAACY,aAAa,CAAC;MAEhC;MACAD,GAAG,IAAIT,UAAU,CAACkB,KAAI,CAAC,CAAC,CAAC,CAAC,CAACS,QAAQ,CAAC,EAAE,CAAC,CAACC,QAAQ,CAAC,EAAE,EAAE,GAAG,CAAC;MACzD;MACAnB,GAAG,IAAIS,KAAI,CAAC,CAAC,CAAC,CAACO,KAAK,CAAC,CAAC,CAAC,CAACI,MAAM,CAAC9B,eAAe,CAACmB,KAAI,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,EAAE,GAAG,CAAC;;EAClE,SAAAE,GAAA;IAAAG,UAAA,CAAAF,CAAA,CAAAD,GAAA;EAAA;IAAAG,UAAA,CAAAD,CAAA;EAAA;EAED,OAAOb,GAAG;AACZ;AAEA,OAAM,SAAUqB,kBAAkBA,CAACC,CAAU,EAAEvB,KAAyB;EACtE;EACA,IAAIC,GAAG,GAAGL,QAAQ;EAElB;EACA;EACA,IAAMM,aAAa,GAAG,IAAI;EAC1BD,GAAG,IAAIsB,CAAC,GAAG5B,WAAW,GAAGD,YAAY;EACrCO,GAAG,IAAIX,UAAU,CAACY,aAAa,CAAC;EAEhC;EACA,OAAOJ,WAAW,CAACG,GAAG,EAAED,KAAK,CAAC;AAChC"},"metadata":{},"sourceType":"module","externalDependencies":[]}