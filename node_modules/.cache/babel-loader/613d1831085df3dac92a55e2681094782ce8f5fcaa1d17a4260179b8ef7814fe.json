{"ast":null,"code":"import _regeneratorRuntime from \"D:/CC/Server/prototype/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _toConsumableArray from \"D:/CC/Server/prototype/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _asyncToGenerator from \"D:/CC/Server/prototype/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport _slicedToArray from \"D:/CC/Server/prototype/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { useConfig } from './useConfig';\nimport { useCallback, useState } from 'react';\nimport { useEthers } from './useEthers';\nimport { estimateContractFunctionGasLimit, usePromiseTransaction } from './usePromiseTransaction';\nimport { useReadonlyNetworks } from '../providers';\nimport { getSignerFromOptions } from '../helpers/getSignerFromOptions';\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function connectContractToSigner(contract, options, librarySigner) {\n  if (contract.signer) {\n    return contract;\n  }\n  if (options && 'signer' in options) {\n    return contract.connect(options.signer);\n  }\n  if (librarySigner) {\n    return contract.connect(librarySigner);\n  }\n  throw new TypeError('No signer available in contract, options or library');\n}\n/**\n * Hook returns an object with four variables: ``state`` , ``send``, ``events`` , and ``resetState``.\n *\n * The `state` represents the status of transaction. See {@link TransactionStatus}.\n *\n * `resetState` can be used to reset the state to `None` after a transaction attempt has either succeeded or failed.\n *\n * The `events` is a array of parsed transaction events of type [LogDescription](https://docs.ethers.io/v5/api/utils/abi/interface/#LogDescription).\n *\n * To send a transaction use `send` function returned by `useContractFunction`.\n * The function forwards arguments to ethers.js contract object, so that arguments map 1 to 1 with Solidity function arguments.\n * Additionally, there can be one extra argument - [TransactionOverrides](https://docs.ethers.io/v5/api/contract/contract/#contract-functionsSend), which can be used to manipulate transaction parameters like gasPrice, nonce, etc\n *\n * If typechain contract is supplied as contract parameter then function name and send arguments will be type checked.\n * More on type checking [here](https://usedapp-docs.netlify.app/docs/Guides/Reading/Typechain).\n * @public\n * @param contract contract which function is to be called , also see [Contract](https://docs.ethers.io/v5/api/contract/contract/)\n * @param functionName name of function to call\n * @param options additional options of type {@link TransactionOptions}\n * @returns {} object with variables: `send` , `state` , `events`: `{ send: (...args: any[]) => void, state: TransactionStatus, events: LogDescription[] }`.\n *\n * @example\n * const { state, send } = useContractFunction(contract, 'deposit', { transactionName: 'Wrap' })\n *\n * const depositEther = (etherAmount: string) => {\n *   send({ value: utils.parseEther(etherAmount) })\n * }\n * @example\n * const { state, send } = useContractFunction(contract, 'withdraw', { transactionName: 'Unwrap' })\n *\n * const withdrawEther = (wethAmount: string) => {\n *   send(utils.parseEther(wethAmount))\n * }\n */\nexport function useContractFunction(contract, functionName, options) {\n  var _a, _b, _c;\n  var _useEthers = useEthers(),\n    library = _useEthers.library,\n    chainId = _useEthers.chainId;\n  var transactionChainId = options && 'chainId' in options && (options === null || options === void 0 ? void 0 : options.chainId) || chainId;\n  var _usePromiseTransactio = usePromiseTransaction(transactionChainId, options),\n    promiseTransaction = _usePromiseTransactio.promiseTransaction,\n    state = _usePromiseTransactio.state,\n    resetState = _usePromiseTransactio.resetState;\n  var _useState = useState(undefined),\n    _useState2 = _slicedToArray(_useState, 2),\n    events = _useState2[0],\n    setEvents = _useState2[1];\n  var config = useConfig();\n  var gasLimitBufferPercentage = (_c = (_b = (_a = options === null || options === void 0 ? void 0 : options.gasLimitBufferPercentage) !== null && _a !== void 0 ? _a : options === null || options === void 0 ? void 0 : options.bufferGasLimitPercentage) !== null && _b !== void 0 ? _b : config === null || config === void 0 ? void 0 : config.gasLimitBufferPercentage) !== null && _c !== void 0 ? _c : 0;\n  var providers = useReadonlyNetworks();\n  var provider = transactionChainId && providers[transactionChainId];\n  var send = useCallback( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    var _a,\n      numberOfArgs,\n      _len,\n      args,\n      _key,\n      hasOpts,\n      signer,\n      contractWithSigner,\n      opts,\n      gasLimit,\n      modifiedOpts,\n      modifiedArgs,\n      receipt,\n      _events,\n      _args = arguments;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          if (!contract) {\n            _context.next = 33;\n            break;\n          }\n          numberOfArgs = contract.interface.getFunction(functionName).inputs.length;\n          for (_len = _args.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = _args[_key];\n          }\n          hasOpts = args.length > numberOfArgs;\n          if (!(args.length !== numberOfArgs && args.length !== numberOfArgs + 1)) {\n            _context.next = 6;\n            break;\n          }\n          throw new Error(\"Invalid number of arguments for function \\\"\".concat(functionName, \"\\\".\"));\n        case 6:\n          signer = getSignerFromOptions(provider, options, library);\n          contractWithSigner = connectContractToSigner(contract, options, signer);\n          opts = hasOpts ? args[args.length - 1] : undefined;\n          if (!(typeof opts === 'object' && Object.prototype.hasOwnProperty.call(opts, 'gasLimit'))) {\n            _context.next = 13;\n            break;\n          }\n          _context.t0 = opts.gasLimit;\n          _context.next = 25;\n          break;\n        case 13:\n          _context.next = 15;\n          return estimateContractFunctionGasLimit(contractWithSigner, functionName, args, gasLimitBufferPercentage);\n        case 15:\n          _context.t2 = _a = _context.sent;\n          _context.t1 = _context.t2 !== null;\n          if (!_context.t1) {\n            _context.next = 19;\n            break;\n          }\n          _context.t1 = _a !== void 0;\n        case 19:\n          if (!_context.t1) {\n            _context.next = 23;\n            break;\n          }\n          _context.t3 = _a;\n          _context.next = 24;\n          break;\n        case 23:\n          _context.t3 = null;\n        case 24:\n          _context.t0 = _context.t3;\n        case 25:\n          gasLimit = _context.t0;\n          modifiedOpts = Object.assign({\n            gasLimit: gasLimit\n          }, opts);\n          modifiedArgs = hasOpts ? args.slice(0, args.length - 1) : args;\n          _context.next = 30;\n          return promiseTransaction(contractWithSigner[functionName].apply(contractWithSigner, _toConsumableArray(modifiedArgs).concat([modifiedOpts])), {\n            safeTransaction: {\n              to: contract.address,\n              value: opts === null || opts === void 0 ? void 0 : opts.value,\n              data: contract.interface.encodeFunctionData(functionName, modifiedArgs),\n              safeTxGas: gasLimit !== null && gasLimit !== void 0 ? gasLimit : undefined\n            }\n          });\n        case 30:\n          receipt = _context.sent;\n          if (receipt === null || receipt === void 0 ? void 0 : receipt.logs) {\n            _events = receipt.logs.reduce(function (accumulatedLogs, log) {\n              try {\n                return log.address.toLowerCase() === contract.address.toLowerCase() ? [].concat(_toConsumableArray(accumulatedLogs), [contract.interface.parseLog(log)]) : accumulatedLogs;\n              } catch (_err) {\n                return accumulatedLogs;\n              }\n            }, []);\n            setEvents(_events);\n          }\n          return _context.abrupt(\"return\", receipt);\n        case 33:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  })), [contract, functionName, options, provider, library, gasLimitBufferPercentage, promiseTransaction]);\n  return {\n    send: send,\n    state: state,\n    events: events,\n    resetState: resetState\n  };\n}","map":{"version":3,"names":["useConfig","useCallback","useState","useEthers","estimateContractFunctionGasLimit","usePromiseTransaction","useReadonlyNetworks","getSignerFromOptions","connectContractToSigner","contract","options","librarySigner","signer","connect","TypeError","useContractFunction","functionName","_useEthers","library","chainId","transactionChainId","_usePromiseTransactio","promiseTransaction","state","resetState","_useState","undefined","_useState2","_slicedToArray","events","setEvents","config","gasLimitBufferPercentage","_c","_b","_a","bufferGasLimitPercentage","providers","provider","send","_asyncToGenerator","_regeneratorRuntime","mark","_callee","numberOfArgs","_len","args","_key","hasOpts","contractWithSigner","opts","gasLimit","modifiedOpts","modifiedArgs","receipt","_events","_args","arguments","wrap","_callee$","_context","prev","next","interface","getFunction","inputs","length","Array","Error","concat","Object","prototype","hasOwnProperty","call","t0","t2","sent","t1","t3","assign","slice","apply","_toConsumableArray","safeTransaction","to","address","value","data","encodeFunctionData","safeTxGas","logs","reduce","accumulatedLogs","log","toLowerCase","parseLog","_err","abrupt","stop"],"sources":["D:\\CC\\Server\\prototype\\node_modules\\@usedapp\\core\\src\\hooks\\useContractFunction.ts"],"sourcesContent":["import { TransactionOptions } from '../model/TransactionOptions'\nimport { useConfig } from './useConfig'\nimport { Contract, Signer, providers } from 'ethers'\nimport { useCallback, useState } from 'react'\nimport { useEthers } from './useEthers'\nimport { estimateContractFunctionGasLimit, usePromiseTransaction } from './usePromiseTransaction'\nimport { LogDescription } from 'ethers/lib/utils'\nimport { ContractFunctionNames, Falsy, Params, TypedContract } from '../model/types'\nimport { TransactionReceipt } from '@ethersproject/abstract-provider'\nimport { useReadonlyNetworks } from '../providers'\nimport { ChainId } from '../constants'\nimport { getSignerFromOptions } from '../helpers/getSignerFromOptions'\n\n/**\n * @internal Intended for internal use - use it on your own risk\n */\nexport function connectContractToSigner(contract: Contract, options?: TransactionOptions, librarySigner?: Signer) {\n  if (contract.signer) {\n    return contract\n  }\n\n  if (options && 'signer' in options) {\n    return contract.connect(options.signer)\n  }\n\n  if (librarySigner) {\n    return contract.connect(librarySigner)\n  }\n\n  throw new TypeError('No signer available in contract, options or library')\n}\n\n/**\n * Hook returns an object with four variables: ``state`` , ``send``, ``events`` , and ``resetState``.\n *\n * The `state` represents the status of transaction. See {@link TransactionStatus}.\n *\n * `resetState` can be used to reset the state to `None` after a transaction attempt has either succeeded or failed.\n *\n * The `events` is a array of parsed transaction events of type [LogDescription](https://docs.ethers.io/v5/api/utils/abi/interface/#LogDescription).\n *\n * To send a transaction use `send` function returned by `useContractFunction`.\n * The function forwards arguments to ethers.js contract object, so that arguments map 1 to 1 with Solidity function arguments.\n * Additionally, there can be one extra argument - [TransactionOverrides](https://docs.ethers.io/v5/api/contract/contract/#contract-functionsSend), which can be used to manipulate transaction parameters like gasPrice, nonce, etc\n *\n * If typechain contract is supplied as contract parameter then function name and send arguments will be type checked.\n * More on type checking [here](https://usedapp-docs.netlify.app/docs/Guides/Reading/Typechain).\n * @public\n * @param contract contract which function is to be called , also see [Contract](https://docs.ethers.io/v5/api/contract/contract/)\n * @param functionName name of function to call\n * @param options additional options of type {@link TransactionOptions}\n * @returns {} object with variables: `send` , `state` , `events`: `{ send: (...args: any[]) => void, state: TransactionStatus, events: LogDescription[] }`.\n *\n * @example\n * const { state, send } = useContractFunction(contract, 'deposit', { transactionName: 'Wrap' })\n *\n * const depositEther = (etherAmount: string) => {\n *   send({ value: utils.parseEther(etherAmount) })\n * }\n * @example\n * const { state, send } = useContractFunction(contract, 'withdraw', { transactionName: 'Unwrap' })\n *\n * const withdrawEther = (wethAmount: string) => {\n *   send(utils.parseEther(wethAmount))\n * }\n */\nexport function useContractFunction<T extends TypedContract, FN extends ContractFunctionNames<T>>(\n  contract: T | Falsy,\n  functionName: FN,\n  options?: TransactionOptions\n) {\n  const { library, chainId } = useEthers()\n  const transactionChainId = (options && 'chainId' in options && options?.chainId) || chainId\n  const { promiseTransaction, state, resetState } = usePromiseTransaction(transactionChainId, options)\n  const [events, setEvents] = useState<LogDescription[] | undefined>(undefined)\n\n  const config = useConfig()\n  const gasLimitBufferPercentage =\n    options?.gasLimitBufferPercentage ?? options?.bufferGasLimitPercentage ?? config?.gasLimitBufferPercentage ?? 0\n\n  const providers = useReadonlyNetworks()\n  const provider = (transactionChainId && providers[transactionChainId as ChainId])!\n\n  const send = useCallback(\n    async (...args: Params<T, FN>): Promise<TransactionReceipt | undefined> => {\n      if (contract) {\n        const numberOfArgs = contract.interface.getFunction(functionName).inputs.length\n        const hasOpts = args.length > numberOfArgs\n        if (args.length !== numberOfArgs && args.length !== numberOfArgs + 1) {\n          throw new Error(`Invalid number of arguments for function \"${functionName}\".`)\n        }\n\n        const signer = getSignerFromOptions(provider as providers.BaseProvider, options, library)\n\n        const contractWithSigner = connectContractToSigner(contract, options, signer)\n        const opts = hasOpts ? args[args.length - 1] : undefined\n\n        const gasLimit =\n          typeof opts === 'object' && Object.prototype.hasOwnProperty.call(opts, 'gasLimit')\n            ? opts.gasLimit\n            : (await estimateContractFunctionGasLimit(\n                contractWithSigner,\n                functionName,\n                args,\n                gasLimitBufferPercentage\n              )) ?? null\n\n        const modifiedOpts = {\n          gasLimit,\n          ...opts,\n        }\n        const modifiedArgs = hasOpts ? args.slice(0, args.length - 1) : args\n\n        const receipt = await promiseTransaction(contractWithSigner[functionName](...modifiedArgs, modifiedOpts), {\n          safeTransaction: {\n            to: contract.address,\n            value: opts?.value,\n            data: contract.interface.encodeFunctionData(functionName, modifiedArgs),\n            safeTxGas: gasLimit ?? undefined,\n          },\n        })\n        if (receipt?.logs) {\n          const events = receipt.logs.reduce((accumulatedLogs, log) => {\n            try {\n              return log.address.toLowerCase() === contract.address.toLowerCase()\n                ? [...accumulatedLogs, contract.interface.parseLog(log)]\n                : accumulatedLogs\n            } catch (_err) {\n              return accumulatedLogs\n            }\n          }, [] as LogDescription[])\n          setEvents(events)\n        }\n        return receipt\n      }\n    },\n    [contract, functionName, options, provider, library, gasLimitBufferPercentage, promiseTransaction]\n  )\n\n  return { send, state, events, resetState }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}