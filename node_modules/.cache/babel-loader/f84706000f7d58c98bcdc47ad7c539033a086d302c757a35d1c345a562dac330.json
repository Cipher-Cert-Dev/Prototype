{"ast":null,"code":"import { useMemo } from 'react';\nimport { useRawCalls } from './useRawCalls';\nimport { decodeCallResult, encodeCallData } from '../helpers';\nimport { useChainId } from './useChainId';\nimport { useConfig } from './useConfig';\n/**\n * Makes a call to a specific method of a specific contract and returns the value or an error if present.\n * The hook will cause the component to refresh when a new block is mined and the return value changes.\n * A syntax sugar for {@link useRawCall} that uses ABI, function name, and arguments instead of raw data.\n * If typechain contract is used in `call` parameter then method name and arguments will be type checked.\n * Result will be typed as well.\n *\n * More on type checking [here](https://usedapp-docs.netlify.app/docs/Guides/Reading/Typechain).\n *\n * @public\n * @param call a single call to a contract, also see {@link Call}\n * @returns The hook returns {@link CallResult} type.\n *\n * @example\n * function useTotalSupply(tokenAddress: string | undefined): BigNumber | undefined {\n *    const { value, error } = useCall(tokenAddress && {\n *      contract: new Contract(tokenAddress, ERC20Interface),\n *      method: 'totalSupply',\n *      args: []\n *    }) ?? {}\n *    if(error) {\n *      console.error(error.message)\n *      return undefined\n *    }\n *    return value?.[0]\n * }\n */\nexport function useCall(call) {\n  var queryParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return useCalls([call], queryParams)[0];\n}\n/**\n * Makes calls to specific methods of specific contracts and returns values or an error if present.\n * The hook will cause the component to refresh when a new block is mined and the return values change.\n * A syntax sugar for {@link useRawCalls} that uses ABI, function name, and arguments instead of raw data.\n * @public\n * @param calls a list of contract calls, also see {@link Call}.\n * @param queryParams see {@link QueryParams}.\n * @returns a list of results (see {@link CallResult}).\n *\n * @example\n * function useTotalSupplies(tokenAddresses: string[] | undefined): (BigNumber | undefined)[] {\n *   const calls = tokenAddresses?.map(address => ({\n *     contract: new Contract(address, ERC20Interface),\n *     method: 'totalSupply',\n *     args: []\n *   })) ?? []\n *   const results = useCalls(calls) ?? []\n *   results.forEach((result, idx) => {\n *     if(result && result.error) {\n *       console.error(`Error encountered calling 'totalSupply' on ${calls[idx]?.contract.address}: ${result.error.message}`)\n *     }\n *   })\n *   return results.map(result => result?.value?.[0])\n * }\n */\nexport function useCalls(calls) {\n  var queryParams = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  var chainId = useChainId({\n    queryParams: queryParams\n  });\n  var _useConfig = useConfig(),\n    refresh = _useConfig.refresh;\n  var potentialRawCalls = useMemo(function () {\n    return calls.map(function (call) {\n      var _a;\n      return chainId !== undefined ? encodeCallData(call, chainId, Object.assign(Object.assign({}, queryParams), {\n        refresh: (_a = queryParams.refresh) !== null && _a !== void 0 ? _a : refresh\n      })) : undefined;\n    });\n  }, [JSON.stringify(calls.map(function (call) {\n    return call && {\n      address: call.contract.address.toLowerCase(),\n      method: call.method,\n      args: call.args\n    };\n  })), chainId]);\n  var rawCalls = useMemo(function () {\n    return potentialRawCalls.map(function (potentialCall) {\n      return potentialCall instanceof Error ? undefined : potentialCall;\n    });\n  }, [potentialRawCalls]);\n  var results = useRawCalls(rawCalls);\n  return useMemo(function () {\n    return results.map(function (result, idx) {\n      if (potentialRawCalls[idx] instanceof Error) {\n        return {\n          value: undefined,\n          error: potentialRawCalls[idx]\n        };\n      }\n      return decodeCallResult(calls[idx], result);\n    });\n  }, [results]);\n}","map":{"version":3,"names":["useMemo","useRawCalls","decodeCallResult","encodeCallData","useChainId","useConfig","useCall","call","queryParams","arguments","length","undefined","useCalls","calls","chainId","_useConfig","refresh","potentialRawCalls","map","Object","assign","_a","JSON","stringify","address","contract","toLowerCase","method","args","rawCalls","potentialCall","Error","results","result","idx","value","error"],"sources":["D:\\CC\\Server\\prototype\\node_modules\\@usedapp\\core\\src\\hooks\\useCall.ts"],"sourcesContent":["import { useMemo } from 'react'\nimport { Contract } from 'ethers'\nimport { ContractMethodNames, Falsy, Params, TypedContract } from '../model/types'\nimport { useRawCalls } from './useRawCalls'\nimport { CallResult, decodeCallResult, encodeCallData } from '../helpers'\nimport { QueryParams } from '../constants/type/QueryParams'\nimport { useChainId } from './useChainId'\nimport { useConfig } from './useConfig'\n\n/**\n * Represents a single call to a contract that can be included in multicall.\n *\n * Typechecking:\n *\n * If you want a variable of type Call to be type checked you need to pass a typechain contract type as in below example\n *\n * ```tsx\n * const typedCall: Call<ERC20> = { contract: ERC20Contract, method: 'name', args: [] }\n * ```\n *\n * If you also supply a method name in type arguments will also be type checked\n *\n * ```tsx\n * const typedCall: Call<ERC20, 'name'> = { contract: ERC20Contract, method: 'name', args: [] }\n * ```\n *\n * @public\n */\nexport interface Call<T extends TypedContract = Contract, MN extends ContractMethodNames<T> = ContractMethodNames<T>> {\n  /**\n   * contract instance, see [Contract](https://docs.ethers.io/v5/api/contract/contract/)\n   */\n  contract: T\n  /**\n   * function name\n   */\n  method: MN\n  /**\n   * arguments for the function\n   */\n  args: Params<T, MN>\n}\n\n/**\n * Makes a call to a specific method of a specific contract and returns the value or an error if present.\n * The hook will cause the component to refresh when a new block is mined and the return value changes.\n * A syntax sugar for {@link useRawCall} that uses ABI, function name, and arguments instead of raw data.\n * If typechain contract is used in `call` parameter then method name and arguments will be type checked.\n * Result will be typed as well.\n *\n * More on type checking [here](https://usedapp-docs.netlify.app/docs/Guides/Reading/Typechain).\n *\n * @public\n * @param call a single call to a contract, also see {@link Call}\n * @returns The hook returns {@link CallResult} type.\n *\n * @example\n * function useTotalSupply(tokenAddress: string | undefined): BigNumber | undefined {\n *    const { value, error } = useCall(tokenAddress && {\n *      contract: new Contract(tokenAddress, ERC20Interface),\n *      method: 'totalSupply',\n *      args: []\n *    }) ?? {}\n *    if(error) {\n *      console.error(error.message)\n *      return undefined\n *    }\n *    return value?.[0]\n * }\n */\nexport function useCall<T extends TypedContract, MN extends ContractMethodNames<T>>(\n  call: Call<T, MN> | Falsy,\n  queryParams: QueryParams = {}\n): CallResult<T, MN> {\n  return useCalls([call], queryParams)[0]\n}\n\n/**\n * Makes calls to specific methods of specific contracts and returns values or an error if present.\n * The hook will cause the component to refresh when a new block is mined and the return values change.\n * A syntax sugar for {@link useRawCalls} that uses ABI, function name, and arguments instead of raw data.\n * @public\n * @param calls a list of contract calls, also see {@link Call}.\n * @param queryParams see {@link QueryParams}.\n * @returns a list of results (see {@link CallResult}).\n *\n * @example\n * function useTotalSupplies(tokenAddresses: string[] | undefined): (BigNumber | undefined)[] {\n *   const calls = tokenAddresses?.map(address => ({\n *     contract: new Contract(address, ERC20Interface),\n *     method: 'totalSupply',\n *     args: []\n *   })) ?? []\n *   const results = useCalls(calls) ?? []\n *   results.forEach((result, idx) => {\n *     if(result && result.error) {\n *       console.error(`Error encountered calling 'totalSupply' on ${calls[idx]?.contract.address}: ${result.error.message}`)\n *     }\n *   })\n *   return results.map(result => result?.value?.[0])\n * }\n */\nexport function useCalls(calls: (Call | Falsy)[], queryParams: QueryParams = {}): CallResult<Contract, string>[] {\n  const chainId = useChainId({ queryParams })\n  const { refresh } = useConfig()\n\n  const potentialRawCalls = useMemo(\n    () =>\n      calls.map((call) =>\n        chainId !== undefined\n          ? encodeCallData(call, chainId, { ...queryParams, refresh: queryParams.refresh ?? refresh })\n          : undefined\n      ),\n    [\n      JSON.stringify(\n        calls.map(\n          (call) => call && { address: call.contract.address.toLowerCase(), method: call.method, args: call.args }\n        )\n      ),\n      chainId,\n    ]\n  )\n\n  const rawCalls = useMemo(\n    () => potentialRawCalls.map((potentialCall) => (potentialCall instanceof Error ? undefined : potentialCall)),\n    [potentialRawCalls]\n  )\n\n  const results = useRawCalls(rawCalls)\n  return useMemo(\n    () =>\n      results.map((result, idx) => {\n        if (potentialRawCalls[idx] instanceof Error) {\n          return { value: undefined, error: potentialRawCalls[idx] as Error }\n        }\n        return decodeCallResult(calls[idx], result)\n      }),\n    [results]\n  )\n}\n"],"mappings":"AAAA,SAASA,OAAO,QAAQ,OAAO;AAG/B,SAASC,WAAW,QAAQ,eAAe;AAC3C,SAAqBC,gBAAgB,EAAEC,cAAc,QAAQ,YAAY;AAEzE,SAASC,UAAU,QAAQ,cAAc;AACzC,SAASC,SAAS,QAAQ,aAAa;AAoCvC;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BA,OAAM,SAAUC,OAAOA,CACrBC,IAAyB,EACI;EAAA,IAA7BC,WAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAA2B,EAAE;EAE7B,OAAOG,QAAQ,CAAC,CAACL,IAAI,CAAC,EAAEC,WAAW,CAAC,CAAC,CAAC,CAAC;AACzC;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;AAyBA,OAAM,SAAUI,QAAQA,CAACC,KAAuB,EAA+B;EAAA,IAA7BL,WAAA,GAAAC,SAAA,CAAAC,MAAA,QAAAD,SAAA,QAAAE,SAAA,GAAAF,SAAA,MAA2B,EAAE;EAC7E,IAAMK,OAAO,GAAGV,UAAU,CAAC;IAAEI,WAAW,EAAXA;EAAW,CAAE,CAAC;EAC3C,IAAAO,UAAA,GAAoBV,SAAS,EAAE;IAAvBW,OAAO,GAAAD,UAAA,CAAPC,OAAO;EAEf,IAAMC,iBAAiB,GAAGjB,OAAO,CAC/B;IAAA,OACEa,KAAK,CAACK,GAAG,CAAC,UAACX,IAAI,EAAI;;MACjB,OAAAO,OAAO,KAAKH,SAAS,GACjBR,cAAc,CAACI,IAAI,EAAEO,OAAO,EAAAK,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAAOZ,WAAW;QAAEQ,OAAO,EAAE,CAAAK,EAAA,GAAAb,WAAW,CAACQ,OAAO,cAAAK,EAAA,cAAAA,EAAA,GAAIL;MAAO,GAAG,GAC1FL,SAAS;KAAA,CACd;EAAA,GACH,CACEW,IAAI,CAACC,SAAS,CACZV,KAAK,CAACK,GAAG,CACP,UAACX,IAAI;IAAA,OAAKA,IAAI,IAAI;MAAEiB,OAAO,EAAEjB,IAAI,CAACkB,QAAQ,CAACD,OAAO,CAACE,WAAW,EAAE;MAAEC,MAAM,EAAEpB,IAAI,CAACoB,MAAM;MAAEC,IAAI,EAAErB,IAAI,CAACqB;IAAI,CAAE;EAAA,EACzG,CACF,EACDd,OAAO,CACR,CACF;EAED,IAAMe,QAAQ,GAAG7B,OAAO,CACtB;IAAA,OAAMiB,iBAAiB,CAACC,GAAG,CAAC,UAACY,aAAa;MAAA,OAAMA,aAAa,YAAYC,KAAK,GAAGpB,SAAS,GAAGmB,aAAa;IAAA,CAAC,CAAC;EAAA,GAC5G,CAACb,iBAAiB,CAAC,CACpB;EAED,IAAMe,OAAO,GAAG/B,WAAW,CAAC4B,QAAQ,CAAC;EACrC,OAAO7B,OAAO,CACZ;IAAA,OACEgC,OAAO,CAACd,GAAG,CAAC,UAACe,MAAM,EAAEC,GAAG,EAAI;MAC1B,IAAIjB,iBAAiB,CAACiB,GAAG,CAAC,YAAYH,KAAK,EAAE;QAC3C,OAAO;UAAEI,KAAK,EAAExB,SAAS;UAAEyB,KAAK,EAAEnB,iBAAiB,CAACiB,GAAG;QAAU,CAAE;;MAErE,OAAOhC,gBAAgB,CAACW,KAAK,CAACqB,GAAG,CAAC,EAAED,MAAM,CAAC;IAC7C,CAAC,CAAC;EAAA,GACJ,CAACD,OAAO,CAAC,CACV;AACH"},"metadata":{},"sourceType":"module","externalDependencies":[]}